import { TutorialStep } from "$/components/tutorials/TutorialStep"
import { TutorialContentFooter } from "$/components/tutorials/TutorialContentFooter"

export const files = import.meta.glob("./files/*", { eager: true, query: "?raw" })

## useSWR - Smart Data Fetching

useSWR provides smart data fetching with caching and automatic revalidation. It's perfect for building fast, responsive apps.

<TutorialStep 
  stepId="use-swr-basic"
  validator={(code) => {
    // Check if the code uses useSWR with fetcher function
    return code.includes('useSWR(') && code.includes('fetcher') && code.includes('isLoading') && code.includes('/api/user')
  }}
>
  Let's start with basic useSWR usage. Create a fetcher function and use it with useSWR:

  ```jsx
  import { useSWR } from "kaioken/swr"

  const fetcher = async (url) => {
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 1000))
    if (url === '/api/user') {
      return { name: 'John Doe', email: 'john@example.com' }
    }
    throw new Error('User not found')
  }

  export function App() {
    const { data, error, isLoading } = useSWR('/api/user', fetcher)

    if (error) return <div>Failed to load user</div>
    if (isLoading) return <div>Loading...</div>
    
    return (
      <div>
        <h1>User Profile</h1>
        <p>Name: {data.name}</p>
        <p>Email: {data.email}</p>
      </div>
    )
  }
  ```

  useSWR takes a key (URL) and a fetcher function. The key is used for caching and deduplication.
</TutorialStep>

<TutorialStep 
  stepId="use-swr-shared-cache"
  validator={(code) => {
    // Check if the code has multiple components using the same SWR key
    return code.includes('UserProfile') && code.includes('UserSettings') && code.includes('useSWR') && code.includes('/api/user')
  }}
>
  Let's create multiple components that share the same data through SWR's automatic caching:

  ```jsx
  import { useSWR } from "kaioken/swr"

  const fetcher = async (url) => {
    console.log('Fetching:', url) // You'll see this only once!
    await new Promise(resolve => setTimeout(resolve, 1000))
    if (url === '/api/user') {
      return { name: 'John Doe', email: 'john@example.com', age: 30 }
    }
    throw new Error('User not found')
  }

  function UserProfile() {
    const { data, isLoading } = useSWR('/api/user', fetcher)
    
    if (isLoading) return <div>Loading profile...</div>
    
    return (
      <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px' }}>
        <h2>Profile</h2>
        <p>Name: {data.name}</p>
        <p>Age: {data.age}</p>
      </div>
    )
  }

  function UserSettings() {
    const { data, isLoading } = useSWR('/api/user', fetcher)
    
    if (isLoading) return <div>Loading settings...</div>
    
    return (
      <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px' }}>
        <h2>Settings</h2>
        <p>Email: {data.email}</p>
        <p>Name: {data.name}</p>
      </div>
    )
  }

  export function App() {
    return (
      <div>
        <h1>User Dashboard</h1>
        <UserProfile />
        <UserSettings />
      </div>
    )
  }
  ```

  Both components share the same data automatically! The fetcher only runs once, and updates are shared.
</TutorialStep>

<TutorialStep 
  stepId="use-swr-conditional"
  validator={(code) => {
    // Check if the code uses conditional fetching with null key
    return code.includes('user ?') && code.includes('null') && code.includes('useState') && code.includes('setUser')
  }}
>
  Let's add conditional fetching. Only fetch posts when a user is selected:

  ```jsx
  import { useSWR } from "kaioken/swr"
  import { useState } from "kaioken"

  const fetcher = async (url) => {
    await new Promise(resolve => setTimeout(resolve, 800))
    
    if (url === '/api/user/123') {
      return { id: 123, name: 'John Doe', email: 'john@example.com' }
    }
    if (url === '/api/user/456') {
      return { id: 456, name: 'Jane Smith', email: 'jane@example.com' }
    }
    if (url.includes('/api/posts/')) {
      const userId = url.split('/').pop()
      return [
        { id: 1, title: `Post 1 by User ${userId}`, content: 'Content here...' },
        { id: 2, title: `Post 2 by User ${userId}`, content: 'More content...' }
      ]
    }
    throw new Error('Not found')
  }

  export function App() {
    const [selectedUserId, setSelectedUserId] = useState(null)
    
    const { data: user, isLoading: userLoading } = useSWR(
      selectedUserId ? `/api/user/${selectedUserId}` : null,
      fetcher
    )
    
    const { data: posts, isLoading: postsLoading } = useSWR(
      user ? `/api/posts/${user.id}` : null,
      fetcher
    )
    
    return (
      <div>
        <h1>User Dashboard</h1>
        <div>
          <button onclick={() => setSelectedUserId(123)}>Load User 123</button>
          <button onclick={() => setSelectedUserId(456)}>Load User 456</button>
          <button onclick={() => setSelectedUserId(null)}>Clear</button>
        </div>
        
        {userLoading && <div>Loading user...</div>}
        {user && (
          <div>
            <h2>{user.name}</h2>
            <p>{user.email}</p>
          </div>
        )}
        
        {postsLoading && <div>Loading posts...</div>}
        {posts && (
          <div>
            <h3>Posts</h3>
            {posts.map(post => (
              <div key={post.id}>
                <h4>{post.title}</h4>
                <p>{post.content}</p>
              </div>
            ))}
          </div>
        )}
      </div>
    )
  }
  ```

  Pass `null` as the key to skip fetching. useSWR will only fetch when the key is not null.
</TutorialStep>

<TutorialStep 
  stepId="use-swr-mutate"
  validator={(code) => {
    // Check if the code uses mutate for optimistic updates
    return code.includes('mutate') && code.includes('updateName') && code.includes('...data') && code.includes('false')
  }}
>
  Finally, let's add optimistic updates with the `mutate` function:

  ```jsx
  import { useSWR } from "kaioken/swr"

  const fetcher = async (url) => {
    await new Promise(resolve => setTimeout(resolve, 1000))
    if (url === '/api/user') {
      return { name: 'John Doe', email: 'john@example.com', age: 30 }
    }
    throw new Error('User not found')
  }

  const updateUser = async (newData) => {
    // Simulate API call to update user
    await new Promise(resolve => setTimeout(resolve, 500))
    console.log('User updated on server:', newData)
    return { ...newData, updatedAt: new Date().toISOString() }
  }

  export function App() {
    const { data, isLoading, mutate } = useSWR('/api/user', fetcher)
    
    const updateName = async (newName) => {
      // Optimistically update the UI immediately
      mutate({ ...data, name: newName }, false)
      
      try {
        // Update on server
        const updatedUser = await updateUser({ ...data, name: newName })
        
        // Revalidate to get fresh data from server
        mutate()
      } catch (error) {
        // Revert on error
        mutate()
        alert('Failed to update user')
      }
    }
    
    if (isLoading) return <div>Loading...</div>
    
    return (
      <div>
        <h1>User Profile</h1>
        <p>Name: {data.name}</p>
        <p>Email: {data.email}</p>
        <p>Age: {data.age}</p>
        
        <div>
          <button onclick={() => updateName('John Smith')}>
            Change Name to John Smith
          </button>
          <button onclick={() => updateName('Jane Doe')}>
            Change Name to Jane Doe
          </button>
          <button onclick={() => mutate()}>
            Refresh Data
          </button>
        </div>
      </div>
    )
  }
  ```

  Use `mutate(newData, false)` for optimistic updates, then `mutate()` to revalidate from the server.
</TutorialStep>

<TutorialContentFooter
  previous={{ label: "useAsync", href: "/tutorial/fetching/use-async" }}
  next={{ label: "Introduction", href: "/tutorial/introduction" }}
/>