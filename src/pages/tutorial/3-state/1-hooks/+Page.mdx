import { TutorialStep } from "$/components/tutorials/TutorialStep"
import { TutorialContentFooter } from "$/components/tutorials/TutorialContentFooter"

export const files = import.meta.glob("./files/*", { eager: true, query: "?raw" })

## State & Hooks

State allows components to remember information and react to user interactions. 
Let's build a todo app to learn how state works in Kaioken using the `useState` hook.

<TutorialStep 
  stepId="state-hooks-basic-state"
  validator={(code) => {
    return code.includes('import { useState } from "kaioken"') &&
      code.includes('const [todos, setTodos] = useState([])') &&
      code.includes('Add Todo')
  }}
>
  First, let's add state to track our todos. Import `useState` and create a todos state:

  ```jsx
  import { useState } from "kaioken" // [!code ++]

  export function App() {
    const [todos, setTodos] = useState([])
    
    return (
      |++<ul>++|
        |++{todos.map((todo) => (++|
          |++<li key={todo.id}>++|
            |++<span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>++|
              |++{todo.text}++|
            |++</span>++|
          |++</li>++|
        |++))}++|
      |++</ul>++|
    )
  }
  ```

  `useState([])` creates state with an empty array as the initial value.
  It returns `[currentValue, setterFunction]` that we destructure.
</TutorialStep>

<TutorialStep 
  stepId="state-hooks-add-todo"
  validator={(code) => {
    return code.includes('const addTodo = () => {') &&
      code.includes('setTodos([...todos, newTodo])') &&
      code.includes('onclick={addTodo}')
  }}
>
  Now let's add functionality to create new todos:

  ```jsx
  import { useState } from "kaioken"

  export function App() {
    const [todos, setTodos] = useState([])
    
    const addTodo = () => {
      const newTodo = {
        id: Date.now(),
        text: `Todo ${todos.length + 1}`,
        completed: false
      }
      setTodos([...todos, newTodo])
    }
    
    return (
      <div>
        <h1>Todo App</h1>
        <p>You have {todos.length} todos</p>
        <button |++onclick={addTodo}++|>Add Todo</button>
      </div>
    )
  }
  ```

  We use the spread operator `...todos` to create a new array with the existing todos plus the new one.
</TutorialStep>

<TutorialStep 
  stepId="state-hooks-render-todos"
  validator={(code) => {
    return code.includes('{todos.map(') &&
      code.includes('key={todo.id}') &&
      code.includes('{todo.text}') &&
      code.includes('todo.completed')
  }}
>
  Let's display the todos in a list and show their completion status:

  ```jsx
  import { useState } from "kaioken"

  export function App() {
    const [todos, setTodos] = useState([])
    
    const addTodo = () => {
      const newTodo = {
        id: Date.now(),
        text: `Todo ${todos.length + 1}`,
        completed: false
      }
      setTodos([...todos, newTodo])
    }
    
    return (
      <div>
        <h1>Todo App</h1>
        <p>You have {todos.length} todos</p>
        <button onclick={addTodo}>Add Todo</button>
        
        |++<ul>++|
          |++{todos.map((todo) => (++|
            |++<li key={todo.id}>++|
              |++<span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>++|
                |++{todo.text}++|
              |++</span>++|
            |++</li>++|
          |++))}++|
        |++</ul>++|
      </div>
    )
  }
  ```

  We use `map()` to render each todo, and conditional styling to show completed todos with strikethrough.
</TutorialStep>

<TutorialStep 
  stepId="state-hooks-toggle-todo"
  validator={(code) => {
    return code.includes('const toggleTodo = (id) => {') &&
      code.includes('setTodos(todos.map(') &&
      code.includes('todo.id === id ? { ...todo, completed: !todo.completed } : todo') &&
      code.includes('onclick={() => toggleTodo(todo.id)}')
  }}
>
  Now let's add the ability to toggle todos as completed:

  ```jsx
  import { useState } from "kaioken"

  export function App() {
    const [todos, setTodos] = useState([])
    
    const addTodo = () => {
      const newTodo = {
        id: Date.now(),
        text: `Todo ${todos.length + 1}`,
        completed: false
      }
      setTodos([...todos, newTodo])
    }
    
    const toggleTodo = (id) => {
      setTodos(todos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      ))
    }
    
    return (
      <div>
        <h1>Todo App</h1>
        <p>You have {todos.length} todos</p>
        <button onclick={addTodo}>Add Todo</button>
        
        <ul>
          {todos.map((todo) => (
            <li key={todo.id}>
              <span 
                style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}
                |++onclick={() => toggleTodo(todo.id)}++|
              >
                {todo.text}
              </span>
            </li>
          ))}
        </ul>
      </div>
    )
  }
  ```

  We update state by creating a new array where the clicked todo's `completed` status is toggled.
</TutorialStep>

<TutorialStep 
  stepId="state-hooks-input-state"
  validator={(code) => {
    return code.includes('const [inputValue, setInputValue] = useState("")') &&
      code.includes('value={inputValue}') &&
      code.includes('oninput={(e) => setInputValue(e.target.value)}') &&
      code.includes('text: inputValue')
  }}
>
  Finally, let's add an input field so users can create custom todos:

  ```jsx
  import { useState } from "kaioken"

  export function App() {
    const [todos, setTodos] = useState([])
    const [inputValue, setInputValue] = useState("")
    
    const addTodo = () => {
      if (!inputValue.trim()) return // [!code ++]
      const newTodo = {
        id: Date.now(),
        text: |~~inputValue~~|,
        completed: false
      }
      setTodos([...todos, newTodo])
      setInputValue("") // [!code ++]
    }
    
    const toggleTodo = (id) => {
      setTodos(todos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      ))
    }
    
    return (
      <div>
        <h1>Todo App</h1>
        <p>You have {todos.length} todos</p>
        
        |++<div>++|
          |++<input ++|
            |++type="text"++|
            |++value={inputValue}++|
            |++oninput={(e) => setInputValue(e.target.value)}++|
            |++placeholder="Enter a todo"++|
          |++/>++|
          <button onclick={addTodo}>Add Todo</button>
        |++</div>++|
        
        <ul>
          {todos.map((todo) => (
            <li key={todo.id}>
              <span 
                style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}
                onclick={() => toggleTodo(todo.id)}
              >
                {todo.text}
              </span>
            </li>
          ))}
        </ul>
      </div>
    )
  }
  ```

  We now have a fully functional todo app! Notice how we use multiple state variables and update them independently.
</TutorialStep>

<TutorialContentFooter
  previous={{ label: "Advanced JSX", href: "/tutorial/jsx/advanced" }}
  next={{ label: "Signals", href: "/tutorial/state/signals" }}
/>