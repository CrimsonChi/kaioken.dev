import { TutorialStep } from "$/components/tutorials/TutorialStep"

export const files = import.meta.glob("./files/*", { eager: true, query: "?raw" })

## useAsync - Handle Async Operations

The `useAsync` hook makes it easy to handle asynchronous operations like API calls with automatic loading and error states.

<TutorialStep 
  stepId="use-async-basic"
  validator={(code) => {
    // Check if the code uses useAsync with loading and error states
    return code.includes('useAsync(') && code.includes('loading') && code.includes('error') && code.includes('fetchUser')
  }}
>
  Let's fetch user data with `useAsync`. It automatically handles loading and error states:

  ```jsx
  import { useAsync } from "kaioken"

  const fetchUser = async (id) => {
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 1000))
    if (id === 999) throw new Error("User not found")
    return { id, name: `User ${id}`, email: `user${id}@example.com` }
  }

  export function App() {
    const { data, loading, error } = useAsync(
      () => fetchUser(123),
      [] // Dependencies array
    )
    
    if (loading) return <div>Loading user...</div>
    if (error) return <div>Error: {error.message}</div>
    
    return (
      <div>
        <h1>User Profile</h1>
        <p>Name: {data.name}</p>
        <p>Email: {data.email}</p>
      </div>
    )
  }
  ```

  `useAsync` returns `data`, `loading`, and `error` states automatically.
</TutorialStep>

<TutorialStep 
  stepId="use-async-dependencies"
  validator={(code) => {
    // Check if the code uses dependencies array and useState for userId
    return code.includes('useState') && code.includes('userId') && code.includes('[userId]') && code.includes('setUserId')
  }}
>
  Let's use the dependencies array to refetch when the user ID changes:

  ```jsx
  import { useAsync } from "kaioken"
  import { useState } from "kaioken"

  const fetchUser = async (id) => {
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 1000))
    if (id === 999) throw new Error("User not found")
    return { id, name: `User ${id}`, email: `user${id}@example.com` }
  }

  export function App() {
    const [userId, setUserId] = useState(123)
    
    const { data, loading, error } = useAsync(
      () => fetchUser(userId),
      [userId] // Refetch when userId changes
    )
    
    return (
      <div>
        <h1>User Profile</h1>
        <div>
          <button onclick={() => setUserId(123)}>User 123</button>
          <button onclick={() => setUserId(456)}>User 456</button>
          <button onclick={() => setUserId(999)}>User 999 (Error)</button>
        </div>
        
        {loading && <div>Loading user...</div>}
        {error && <div>Error: {error.message}</div>}
        {data && (
          <div>
            <p>Name: {data.name}</p>
            <p>Email: {data.email}</p>
          </div>
        )}
      </div>
    )
  }
  ```

  The hook refetches automatically when values in the dependencies array change.
</TutorialStep>

<TutorialStep 
  stepId="use-async-conditional"
  validator={(code) => {
    // Check if the code uses conditional fetching by returning null
    return code.includes('user ?') && code.includes('fetchUserPosts') && code.includes(': null')
  }}
>
  Let's add conditional fetching. Only fetch posts when a user is selected:

  ```jsx
  import { useAsync } from "kaioken"
  import { useState } from "kaioken"

  const fetchUser = async (id) => {
    await new Promise(resolve => setTimeout(resolve, 500))
    return { id, name: `User ${id}`, email: `user${id}@example.com` }
  }

  const fetchUserPosts = async (userId) => {
    await new Promise(resolve => setTimeout(resolve, 800))
    return [
      { id: 1, title: `Post 1 by User ${userId}`, content: "Content here..." },
      { id: 2, title: `Post 2 by User ${userId}`, content: "More content..." }
    ]
  }

  export function App() {
    const [userId, setUserId] = useState(null)
    
    const { data: user, loading: userLoading } = useAsync(
      () => userId ? fetchUser(userId) : null,
      [userId]
    )
    
    const { data: posts, loading: postsLoading } = useAsync(
      () => user ? fetchUserPosts(user.id) : null,
      [user]
    )
    
    return (
      <div>
        <h1>User Dashboard</h1>
        <div>
          <button onclick={() => setUserId(123)}>Load User 123</button>
          <button onclick={() => setUserId(456)}>Load User 456</button>
          <button onclick={() => setUserId(null)}>Clear</button>
        </div>
        
        {userLoading && <div>Loading user...</div>}
        {user && (
          <div>
            <h2>{user.name}</h2>
            <p>{user.email}</p>
          </div>
        )}
        
        {postsLoading && <div>Loading posts...</div>}
        {posts && (
          <div>
            <h3>Posts</h3>
            {posts.map(post => (
              <div key={post.id}>
                <h4>{post.title}</h4>
                <p>{post.content}</p>
              </div>
            ))}
          </div>
        )}
      </div>
    )
  }
  ```

  Return `null` from the async function to skip execution conditionally.
</TutorialStep>

<TutorialStep 
  stepId="use-async-error-handling"
  validator={(code) => {
    // Check if the code uses refetch for error handling
    return code.includes('refetch') && code.includes('Try Again') && code.includes('onclick={refetch}')
  }}
>
  Finally, let's add error handling with a retry button:

  ```jsx
  import { useAsync } from "kaioken"
  import { useState } from "kaioken"

  const fetchUser = async (id) => {
    await new Promise(resolve => setTimeout(resolve, 1000))
    // Simulate random errors
    if (Math.random() > 0.7) throw new Error("Network error occurred")
    return { id, name: `User ${id}`, email: `user${id}@example.com` }
  }

  export function App() {
    const [userId, setUserId] = useState(123)
    
    const { data, loading, error, refetch } = useAsync(
      () => fetchUser(userId),
      [userId]
    )
    
    return (
      <div>
        <h1>User Profile</h1>
        <div>
          <button onclick={() => setUserId(123)}>User 123</button>
          <button onclick={() => setUserId(456)}>User 456</button>
        </div>
        
        {loading && <div>Loading user...</div>}
        
        {error && (
          <div style={{ color: 'red', padding: '10px', border: '1px solid red' }}>
            <p>Failed to load user: {error.message}</p>
            <button onclick={refetch}>Try Again</button>
          </div>
        )}
        
        {data && (
          <div>
            <p>Name: {data.name}</p>
            <p>Email: {data.email}</p>
            <button onclick={refetch}>Refresh</button>
          </div>
        )}
      </div>
    )
  }
  ```

  Use the `refetch` function to manually retry failed requests or refresh data.
</TutorialStep>

<div className="flex justify-between">
  <a href="/tutorial/forms" className="link-button">Previous: Forms</a>
  <a href="/tutorial/fetching/use-swr" className="link-button">Next: useSWR</a>
</div> 