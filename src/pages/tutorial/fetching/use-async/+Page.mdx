export const files = import.meta.glob("./files/*", { eager: true, query: "?raw" })

## useAsync - Handle Asynchronous Operations

The `useAsync` hook simplifies handling asynchronous operations like API calls. It manages loading states, errors, and data automatically.

### Basic Usage

Use `useAsync` to fetch data with automatic state management:

```jsx
import { useAsync } from "kaioken"

function UserProfile({ userId }) {
  const { data, loading, error, refetch } = useAsync(
    () => fetchUser(userId),
    [userId] // Dependencies
  )
  
  if (loading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>
  
  return <div>Hello, {data.name}!</div>
}
```

### Hook Return Values

`useAsync` returns an object with these properties:

- **`data`**: The resolved value from the async function
- **`loading`**: Boolean indicating if the operation is in progress
- **`error`**: Any error that occurred during execution
- **`refetch`**: Function to manually trigger the async operation again

### Dependencies Array

The second parameter is a dependencies array (like `useEffect`):

```jsx
// Refetch when userId changes
const { data } = useAsync(() => fetchUser(userId), [userId])

// Fetch only once (empty dependencies)
const { data } = useAsync(() => fetchConfig(), [])

// Always refetch (no dependencies array)
const { data } = useAsync(() => fetchLatestData())
```

### Conditional Execution

Skip execution by returning `null` or `undefined`:

```jsx
const { data: posts } = useAsync(
  () => user ? fetchUserPosts(user.id) : null,
  [user]
)
```

### Error Handling

Handle errors gracefully with the error state:

```jsx
function DataComponent() {
  const { data, loading, error, refetch } = useAsync(fetchData)
  
  if (error) {
    return (
      <div className="error">
        <p>Failed to load data: {error.message}</p>
        <button onclick={refetch}>Try Again</button>
      </div>
    )
  }
  
  // ... rest of component
}
```

### Loading States

Show loading indicators while operations are in progress:

```jsx
function LoadingExample() {
  const { data, loading } = useAsync(fetchSlowData)
  
  return (
    <div>
      <button disabled={loading}>
        {loading ? "Loading..." : "Refresh"}
      </button>
      {data && <DataDisplay data={data} />}
    </div>
  )
}
```

### Multiple Async Operations

Use multiple `useAsync` hooks for different operations:

```jsx
function Dashboard() {
  const { data: user, loading: userLoading } = useAsync(fetchUser)
  const { data: posts, loading: postsLoading } = useAsync(
    () => user ? fetchUserPosts(user.id) : null,
    [user]
  )
  
  return (
    <div>
      {userLoading && <Spinner />}
      {user && <UserHeader user={user} />}
      
      {postsLoading && <PostsSkeleton />}
      {posts && <PostsList posts={posts} />}
    </div>
  )
}
```

### Best Practices

1. **Always handle loading and error states**
2. **Use meaningful dependencies arrays**
3. **Provide fallback UI for error cases**
4. **Consider using skeleton loaders for better UX**
5. **Debounce user input for search operations**

Try interacting with the user profile viewer in the editor. Notice how loading states and error handling work seamlessly!

<div className="flex justify-between">
  <a href="/tutorial/forms" className="link-button">Previous: Forms</a>
  <a href="/tutorial/fetching/use-swr" className="link-button">Next: useSWR</a>
</div> 