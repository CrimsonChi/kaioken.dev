import { TutorialStep } from "$/components/tutorials/TutorialStep"
import { TutorialContentFooter } from "$/components/tutorials/TutorialContentFooter"

export const files = import.meta.glob("./files/*", { eager: true, query: "?raw" })

## Forms - Handle User Input

Forms are essential for collecting user input. Kaioken's Form API makes it simple to handle form state and validation.

<TutorialStep 
  stepId="forms-basic-form"
  validator={(code) => {
    // Check if the code uses useForm and Field components
    return code.includes('useForm({') && code.includes('<Field') && code.includes('initialValues')
  }}
>
  Let's create a basic form with the `useForm` hook. Create a form with name and email fields:

  ```jsx
  import { useForm } from "kaioken/form"

  export function App() {
    const { Field, handleSubmit } = useForm({
      initialValues: {
        name: "",
        email: ""
      },
      onSubmit: ({ state }) => {
        console.log("Form submitted:", state)
        alert(`Hello ${state.name}! Email: ${state.email}`)
      }
    })

    return (
      <form onsubmit={(e) => {
        e.preventDefault()
        handleSubmit()
      }}>
        <h2>User Form</h2>
        
        <Field
          name="name"
          children={(field) => (
            <div>
              <label>Name</label>
              <input
                value={field.state.value}
                oninput={(e) => field.handleChange(e.target.value)}
              />
            </div>
          )}
        />
        
        <Field
          name="email"
          children={(field) => (
            <div>
              <label>Email</label>
              <input
                type="email"
                value={field.state.value}
                oninput={(e) => field.handleChange(e.target.value)}
              />
            </div>
          )}
        />
        
        <button type="submit">Submit</button>
      </form>
    )
  }
  ```

  The `useForm` hook manages form state and the `Field` component handles individual form fields.
</TutorialStep>

<TutorialStep 
  stepId="forms-create-constants"
  
  validator={(code) => {
    // Check if constants.js has input and error styles
    return code.includes('export const inputStyle') && code.includes('export const errorStyle')
  }}
>
  Let's create a `constants.js` file for reusable styles and data:

  ```js
  export const inputStyle = {
    width: "100%",
    padding: "10px",
    border: "1px solid #ddd",
    borderRadius: "4px",
    fontSize: "16px",
    marginBottom: "10px",
  }

  export const errorStyle = {
    color: "#dc3545",
    fontSize: "14px",
    marginTop: "5px",
  }

  export const buttonStyle = {
    backgroundColor: "#007bff",
    color: "white",
    padding: "10px 20px",
    border: "none",
    borderRadius: "4px",
    fontSize: "16px",
    cursor: "pointer"
  }
  ```

  This file will contain shared styles and constants for our form components.
</TutorialStep>

<TutorialStep 
  stepId="forms-create-field-component"
  
  validator={(code) => {
    // Check if FormField component exists and imports constants
    return code.includes('export function FormField') && code.includes('import') && code.includes('errorStyle')
  }}
>
  Create a `FormField.jsx` component for reusable form field logic:

  ```jsx
  import { errorStyle, inputStyle } from "./constants"

  export function FormField({ label, error, required, children }) {
    return (
      <div style={{ marginBottom: "15px" }}>
        <label
          style={{ 
            fontWeight: "bold", 
            marginBottom: "5px", 
            display: "block" 
          }}
        >
          {label} {required && <span style={{ color: "red" }}>*</span>}
        </label>
        {children}
        {error && <div style={errorStyle}>{error}</div>}
      </div>
    )
  }

  export function TextInput({ value, onchange, placeholder, type = "text" }) {
    return (
      <input
        type={type}
        value={value}
        oninput={onchange}
        placeholder={placeholder}
        style={inputStyle}
      />
    )
  }
  ```

  This provides reusable form field components with consistent styling.
</TutorialStep>

<TutorialStep 
  stepId="forms-use-components"
  validator={(code) => {
    // Check if App uses FormField and TextInput components
    return code.includes('import') && code.includes('FormField') && code.includes('TextInput') && code.includes('validators')
  }}
>
  Now update your `App.jsx` to use the new components with validation:

  ```jsx
  import { useForm } from "kaioken/form"
  import { FormField, TextInput } from "./FormField"
  import { buttonStyle } from "./constants"

  export function App() {
    const { Field, Subscribe, handleSubmit } = useForm({
      initialValues: {
        name: "",
        email: ""
      },
      onSubmit: async ({ state }) => {
        console.log("Form submitted:", state)
        // Simulate async submission
        await new Promise(resolve => setTimeout(resolve, 1000))
        alert(`Hello ${state.name}! Email: ${state.email}`)
      }
    })

    return (
      <div style={{ maxWidth: "400px", margin: "0 auto", padding: "20px" }}>
        <form onsubmit={(e) => {
          e.preventDefault()
          handleSubmit()
        }}>
          <h2>Contact Form</h2>
          
          <Field
            name="name"
            validators={{
              onChange: ({ value }) => !value?.trim() && "Name is required"
            }}
            children={(field) => (
              <FormField 
                label="Full Name" 
                error={field.state.errors[0]}
                required
              >
                <TextInput
                  value={field.state.value}
                  onchange={(e) => field.handleChange(e.target.value)}
                  placeholder="Enter your name"
                />
              </FormField>
            )}
          />
          
          <Field
            name="email"
            validators={{
              onChange: ({ value }) => {
                if (!value?.trim()) return "Email is required"
                if (!/\S+@\S+\.\S+/.test(value)) return "Invalid email format"
              }
            }}
            children={(field) => (
              <FormField 
                label="Email Address" 
                error={field.state.errors[0]}
                required
              >
                <TextInput
                  type="email"
                  value={field.state.value}
                  onchange={(e) => field.handleChange(e.target.value)}
                  placeholder="Enter your email"
                />
              </FormField>
            )}
          />
          
          <Subscribe
            selector={(state) => [state.canSubmit, state.isSubmitting]}
            children={([canSubmit, isSubmitting]) => (
              <button
                type="submit"
                disabled={!canSubmit || isSubmitting}
                style={{
                  ...buttonStyle,
                  opacity: (!canSubmit || isSubmitting) ? 0.6 : 1
                }}
              >
                {isSubmitting ? "Submitting..." : "Submit"}
              </button>
            )}
          />
        </form>
      </div>
    )
  }
  ```

  Now you have a clean, modular form system with reusable components and validation!
</TutorialStep>

<TutorialContentFooter
  previous={{ label: "Routing", href: "/tutorial/routing" }}
  next={{ label: "useAsync", href: "/tutorial/fetching/use-async" }}
/>