export const files = import.meta.glob("./files/*", { eager: true, query: "?raw" })

## Forms - Handle User Input with the Form API

Forms are essential for collecting user input in web applications. Kaioken provides a powerful Form API that makes it easy to handle form state, validation, and submission with minimal boilerplate.

### Using the Form API

The Form API provides a declarative approach to form management, inspired by TanStack Form. It handles form state, validation, and submission automatically:

```jsx
import { useForm } from "kaioken/form"

function MyForm() {
  const { Field, Subscribe, handleSubmit } = useForm({
    initialValues: {
      name: "",
      email: ""
    },
    onSubmit: ({ state }) => {
      console.log("Form submitted:", state)
    }
  })

  return (
    <form onsubmit={(e) => {
      e.preventDefault()
      handleSubmit()
    }}>
      <Field
        name="name"
        validators={{
          onChange: ({ value }) => !value?.trim() && "Name is required"
        }}
        children={(field) => (
          <div>
            <label>Name</label>
            <input
              value={field.state.value}
              oninput={(e) => field.handleChange(e.target.value)}
              onblur={field.handleBlur}
            />
            {field.state.errors.length > 0 && (
              <span>{field.state.errors[0]}</span>
            )}
          </div>
        )}
      />
    </form>
  )
}
```

### Form State Management

The Form API automatically manages form state through the `useForm` hook:

- **Initial Values**: Set default values for all form fields
- **Current State**: Access current values and validation status
- **Submission State**: Track if form is submitting and can be submitted

### Field Validation

Each field can have its own validation rules:

```jsx
<Field
  name="email"
  validators={{
    onChange: ({ value }) => {
      if (!value?.trim()) {
        return "Email is required"
      }
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
        return "Please enter a valid email"
      }
    }
  }}
  children={(field) => (
    <div>
      <input
        type="email"
        value={field.state.value}
        oninput={(e) => field.handleChange(e.target.value)}
        onblur={field.handleBlur}
      />
      {field.state.errors.length > 0 && (
        <span>{field.state.errors[0]}</span>
      )}
    </div>
  )}
/>
```

### Form Submission

The Form API handles submission automatically:

```jsx
<Subscribe
  selector={(state) => [state.canSubmit, state.isSubmitting]}
  children={([canSubmit, isSubmitting]) => (
    <button
      type="submit"
      disabled={!canSubmit}
    >
      {isSubmitting ? "Submitting..." : "Submit"}
    </button>
  )}
/>
```

### Key Features

1. **Declarative**: Define validation rules alongside field definitions
2. **Automatic State Management**: No need to manually manage form state
3. **Real-time Validation**: Validation runs as users type
4. **Submission Handling**: Built-in submission state management
5. **Field-level Control**: Each field manages its own state and validation

### Field Types

Handle different input types with the same API:

```jsx
// Text input
<Field
  name="name"
  validators={{ onChange: ({ value }) => !value && "Required" }}
  children={(field) => (
    <input
      value={field.state.value}
      oninput={(e) => field.handleChange(e.target.value)}
    />
  )}
/>

// Select dropdown
<Field
  name="country"
  validators={{ onChange: ({ value }) => !value && "Please select a country" }}
  children={(field) => (
    <select
      value={field.state.value}
      onchange={(e) => field.handleChange(e.target.value)}
    >
      <option value="">Select country</option>
      <option value="US">United States</option>
    </select>
  )}
/>
```

### Best Practices

1. **Use the Form API**: Prefer the Form API over manual state management
2. **Field-level Validation**: Define validation rules close to field definitions
3. **Subscribe to State**: Use `form.Subscribe` for reactive UI updates
4. **Handle Submission**: Always prevent default form submission
5. **Error Display**: Show validation errors near their respective fields

### Advanced Features

- **Cross-field Validation**: Access other field values in validators
- **Async Validation**: Support for asynchronous validation
- **Form Reset**: Reset form to initial state
- **Field Arrays**: Handle dynamic lists of fields

Try filling out the form in the editor. Notice how the Form API automatically handles validation, state management, and submission without any manual work!

<div className="flex justify-between">
  <a href="/tutorial/routing" className="link-button">Previous: Routing</a>
  <a href="/tutorial/fetching/use-async" className="link-button">Next: Data Fetching</a>
</div> 